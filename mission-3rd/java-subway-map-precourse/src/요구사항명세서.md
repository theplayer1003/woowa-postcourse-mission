# 러프
- 프로그램 시작시 초기화 작업
  2호선: 교대 - 강남 - 역삼
  3호선: 교대 - 남부터미널 - 양재 - 매봉
  신분당선: 강남 - 양재 - 양재시민숲

미리 정보를 등록함. 디폴트.

미리 선언되어 있는 도메인
라인, 라인 레포, 스테이션, 스테이션 레포

- 기능
1. 지하철 역 관련 기능
   지하철 역 등록, 삭제 기능. 디폴트 등록된 역은 삭제 불가능 -
   중복된 지하철 역 이름 등록 불가
   역 이름은 2글자 이상 o
   지하철 역 목록 조회 기능

2. 지하철 노선 관련 기능
   지하철 노선 등록 및 삭제
   중복 노선 정보 불가능
   노선 이름 2글자 이상 o
   노선은 상행 종점역과 하행 종점역을 가짐
   목록 조회 기능

3. 지하철 구간 추가 기능
   노선에 구간을 추가하는 기능. 노선에 역을 추가하는 기능임
   구간이란 역과 역 사이를 구간이라고 하며 이 구간들이 모여 노선이 된다.
   하나의 역은 여러 노선에 중복 추가 가능하다.
   역과 역 사이에 새로운 역이 추가되는 기능이 있다.

노선에서 갈래길은 생길 수 없다(?) 갈래길이 뭐임?
노선이 갈라지지 않고 선이란거 같은데?

4. 지하철 구간 삭제 기능
   노선에 등록된 역을 제거할 수 있따.
   종점을 제거한다면 그 다음에 있는 역이 종점이 된다.
   노선에 역이 두개만 남아 있으면 역 제거가 불가능하다.

5. 지하철 노선에 등록된 역 조회 기능
   노선 상행 종점~하행 종점 까지 순서대로 조회 출력.

- 입출 요구사항
  `[INFO], [ERROR] 등 프리픽스가 필요하다`

- 요구사항
  세터 사용 금지, 기본 제공 클래스 필수 활용
  기본 레포를 제공하지만 추가 레포 작성 허용
  네이밍은 통일해야함 무슨무슨Repository
  레포 클래스는 자유롭게 수정 가능


---


# 역 관리 기능
- 역 등록하기
- 역 삭제하기
- 역 조회하기


# 노선 관리 기능
- 노선 등록하기
- 노선 삭제하기
- 노선 조회하기


# 구간 관리 기능
- 구간 등록하기
- 구간 삭제하기

# 지하철 노선도 출력
- 지하철 노선도 출력
  노선 별로 줄줄이 출력
  노선 1
  ~

노선 2
~

---


# 요구사항 명세서

# 도메인

## Station
- 책임
    - 역을 추상화한 클래스, VO
    - 역 이름에 대한 검증
        - 역 이름은 중복되지 않는다
        - 역 이름은 2글자 이상이어야 한다
- 상태
    - `String stationName`
- 메서드
    - `equals()`, `hasCode()`
    - `validateNameLength()`

## Line
- 책임
    - 노선을 추상화한 클래스
    - `Station` 들을 모아 관리하는 일급 컬렉션
    - 지하철 역 목록을 조회한다
- 상태
    - `String lineName`
    - `List<Station> stations`
- 메서드
    - `validateNameLength()`
    - `validateDuplicate()`

## StationRepository
- 책임
    - 역들을 저장하는 레포지토리 클래스
- 상태
    - `List<Station> stations`
- 메서드
    - `List<Station> stations()`: 필드를 읽기전용으로 반환
    - `void addStation(Station station)`: 역 추가
    - `boolean deleteStation(String name)`: 역 제거

## LineRepository
- 책임
    - 노선들을 저장하는 레포지토리 클래스
- 상태
    - `List<Line> lines`
- 메서드
    - `List<Line> lines()`: 필드를 읽기전용으로 반환
    - `void addLine(Line line)`: 노선 추가
    - `boolean deleteLineByName(String name)`: 노선 제거


# Application Layer
## StationService
- 책임
- 상태
- 메서드

## LineService
- 책임
- 상태
- 메서드

# 도메인 시나리오

- 프로그램이 실행되고 `Service` 에게 `초기화` 요청을 한다
    - `Service` 는 지하철 역 `교대역, 강남역, 역삼역, 남부터미널역, 양재역, 양재시민의숲역, 매봉역` 을 생성한다
    - `Service` 는 지하철 노선 `2호선, 3호선, 신분당선` 을 생성한다
        - `2호선`: `교대역`-`강남역`-`역삼역`
        - `3호선`: `교대역`-`남부터미널역`-`양재역`-`매봉역`
        - `신분당선`: `강남역`-`양재역`-`양재시민의숲역`

- `Presentation Layer` 에서 `Station Service` 에게 역 등록을 요청 한다
    - `Station Service` 는 전달받은 문자열로 `Station` 객체를 생성한다
    - `Station Service` 는 `Station`

# 기능 구현 목록
- [ ] 역 관리 기능
    - [ ] 역 등록하기
    - [ ] 역 삭제하기
    - [ ] 역 조회하기
- [ ] 노선 관리 기능
    - [ ] 노선 등록하기
    - [ ] 노선 삭제하기
    - [ ] 노선 조회하기
- [ ] 구간 관리 기능
    - [ ] 구간 등록하기
    - [ ] 구간 삭제하기
- [ ] 지하철 노선도 출력 기능
    - [ ] 전체 노선 조회하기


# 메뉴 계층

```
## 메인 화면
1. 역 관리
	1. 역 등록 - 이름을 입력해서 역을 등록한다
	2. 역 삭제 - 이름을 입력해서 역을 삭제한다
	3. 역 조회 - 모든 역 목록이 조회된다
	B. 돌아가기
2. 노선 관리
	1. 노선 등록 - 노선의 이름과 상,하행 종점역 이름을 입력해서 등록한다
	2. 노선 삭제 - 노선의 이름을 입력해서 삭제한다
	3. 노선 조회 - 현재 노선의 이름 정보만 조회한다
	B. 돌아가기
3. 구간 관리
	1. 구간 등록 - 노선 이름 -> 역이름 -> 순서(위치 값)
	2. 구간 삭제 - 노선 이름 -> 역이름 -> 삭제
	B. 돌아가기
4. 지하철 노선도 출력
Q. 종료
```


---



실무에서 사용하는 '스프링 컨테이너'의 역할을 순수 자바로 흉내 내는 것은 객체지향 설계의 정수(Essence)인 **의존성 주입(Dependency Injection, DI)**을 직접 구현해보는 아주 훌륭한 학습 방법입니다.

이 방식의 핵심은 **"필요한 객체를 내가 직접 만들지 않고(new), 외부(Main)에서 넣어주는 것"**입니다.

단계별로 코드를 리팩토링해보겠습니다. 이 과정을 거치면 `static` 없이도 데이터가 공유되는 마법을 이해하게 됩니다.

---

### 1단계: 레포지토리에서 `static` 제거하기 (평범한 객체로 만들기)

먼저 `StationRepository`를 상태(List)와 행위(Method)를 가진 정상적인 객체로 만듭니다. 이제 이 객체는 `new`를 할 때마다 새로운 리스트를 가집니다.

Java

```
package subway.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class StationRepository {
    // ✅ static 제거: 이제 이 리스트는 객체(인스턴스)마다 별도로 존재합니다.
    private final List<Station> stations = new ArrayList<>();

    public List<Station> findAll() {
        return Collections.unmodifiableList(stations);
    }

    public void save(Station station) {
        stations.add(station);
    }

    public boolean deleteByName(String name) {
        return stations.removeIf(station -> station.getName().equals(name));
    }

    public Optional<Station> findByName(String name) {
        return stations.stream()
                .filter(station -> station.getName().equals(name))
                .findFirst();
    }
}
```

---

### 2단계: 서비스가 레포지토리를 '받아서' 쓰도록 변경 (생성자 주입)

이 부분이 가장 중요합니다. 서비스 내부에서 `new StationRepository()`를 하지 않습니다. 그러면 데이터가 공유되지 않으니까요. 대신 **생성자**를 열어둡니다.

Java

```
package subway.service;

public class StationService {
    private final StationRepository stationRepository;

    // ✅ "레포지토리는 내가 안 만들고, 밖에서 누군가 주면 그걸 쓸게" (의존성 주입)
    public StationService(StationRepository stationRepository) {
        this.stationRepository = stationRepository;
    }

    public void register(String name) {
        // 비즈니스 로직 (중복 검사 등)
        if (stationRepository.findByName(name).isPresent()) {
            throw new IllegalArgumentException("이미 존재하는 역입니다.");
        }
        stationRepository.save(new Station(name));
    }
    
    // ... 기타 메서드
}
```

---

### 3단계: 컨트롤러도 서비스를 '받아서' 쓰도록 변경

마찬가지로 컨트롤러도 서비스를 직접 생성하지 않고 생성자로 받습니다.

Java

```
package subway.controller;

public class SubwayController {
    private final StationService stationService;
    private final LineService lineService;

    // ✅ "전문가(서비스)들을 밖에서 붙여주면 난 지시만 내릴게"
    public SubwayController(StationService stationService, LineService lineService) {
        this.stationService = stationService;
        this.lineService = lineService;
    }

    public void run() {
        // ... 메뉴 입력 받고 로직 수행
    }
}
```

---

### 4단계: `Application` (Main)에서 조립하기 (핵심!)

자, 이제 모든 부품(클래스)이 준비되었습니다. static이 없는데 어떻게 하나의 리스트를 공유할까요?

바로 프로그램의 시작점인 main 메서드에서 객체를 딱 한 번만 생성해서 돌려쓰기 때문입니다.

이곳을 전문 용어로 **Composition Root (조립소)**라고 부릅니다. 스프링 컨테이너가 하는 일이 바로 이겁니다.

Java

```
package subway;

public class Application {
    public static void main(String[] args) {
        // 1. 가장 기초가 되는 저장소(Repository)를 딱 하나만 생성 (싱글톤처럼 동작)
        StationRepository stationRepository = new StationRepository();
        LineRepository lineRepository = new LineRepository();

        // 2. 서비스 생성 (위에서 만든 저장소를 넣어줌 - 주입)
        // stationRepository 객체는 하나지만, 여기서 주입되어 사용됨
        StationService stationService = new StationService(stationRepository);
        LineService lineService = new LineService(lineRepository);

        // 3. 컨트롤러 생성 (위에서 만든 서비스를 넣어줌)
        SubwayController controller = new SubwayController(stationService, lineService);

        // 4. 실행
        controller.run();
    }
}
```

---

### 핵심 정리: 왜 이렇게 하나요?

1. **데이터 공유의 원리:**

    - `main` 함수에서 `new StationRepository()`를 **딱 한 번만** 했습니다.

    - 이 유일한 객체(참조값)가 `Service`를 타고 흘러가서 사용됩니다. 그래서 `static` 없이도 모든 곳에서 같은 리스트를 보게 되는 것입니다.

2. **테스트의 용이성:**

    - 만약 테스트 코드를 짤 때 "가짜 레포지토리"를 쓰고 싶다면?

    - `new StationService(new FakeRepository())` 처럼 갈아끼우기가 매우 쉽습니다. (`static`이면 이게 불가능합니다.)

3. **유연성:**

    - 나중에 "DB 저장소"로 바꾸고 싶다면, `Main` 코드만 `new DbStationRepository()`로 바꾸면 됩니다. 서비스나 컨트롤러 코드는 한 줄도 건드릴 필요가 없습니다.


**이 구조가 이해되신다면, 사실상 스프링 프레임워크의 핵심 원리(DI/IoC)를 80% 이상 이해하신 것과 다름없습니다.**

이 방식으로 작성을 시도해 보시겠어요? 처음에 `Main` 메서드에서 조립하는 과정이 마치 "레고 블록 조립"처럼 느껴져서 꽤 재미있으실 겁니다.



```java
//    public List<Station> stations() {  
//        return Collections.unmodifiableList(stations);  
//    }  
//  
//    public void addStation(Station station) {  
//        stations.add(station);  
//    }  
//  
//    public boolean deleteStation(String name) {  
//        return stations.removeIf(station -> Objects.equals(station.getName(), name));  
//    }
```